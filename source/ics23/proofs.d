// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: proofs.proto

module ics23.proofs;

import google.protobuf;

enum protocVersion = 3012003;

class ExistenceProof
{
    @Proto(1) bytes key = protoDefaultValue!bytes;
    @Proto(2) bytes value = protoDefaultValue!bytes;
    @Proto(3) LeafOp leaf = protoDefaultValue!LeafOp;
    @Proto(4) InnerOp[] path = protoDefaultValue!(InnerOp[]);
}

class NonExistenceProof
{
    @Proto(1) bytes key = protoDefaultValue!bytes;
    @Proto(2) ExistenceProof left = protoDefaultValue!ExistenceProof;
    @Proto(3) ExistenceProof right = protoDefaultValue!ExistenceProof;
}

class CommitmentProof
{
    enum ProofCase
    {
        proofNotSet = 0,
        exist = 1,
        nonexist = 2,
        batch = 3,
        compressed = 4,
    }
    ProofCase _proofCase = ProofCase.proofNotSet;
    @property ProofCase proofCase() { return _proofCase; }
    void clearProof() { _proofCase = ProofCase.proofNotSet; }
    @Oneof("_proofCase") union
    {
        @Proto(1) ExistenceProof _exist = protoDefaultValue!ExistenceProof; mixin(oneofAccessors!_exist);
        @Proto(2) NonExistenceProof _nonexist; mixin(oneofAccessors!_nonexist);
        @Proto(3) BatchProof _batch; mixin(oneofAccessors!_batch);
        @Proto(4) CompressedBatchProof _compressed; mixin(oneofAccessors!_compressed);
    }
}

class LeafOp
{
    @Proto(1) HashOp hash = protoDefaultValue!HashOp;
    @Proto(2) HashOp prehashKey = protoDefaultValue!HashOp;
    @Proto(3) HashOp prehashValue = protoDefaultValue!HashOp;
    @Proto(4) LengthOp length = protoDefaultValue!LengthOp;
    @Proto(5) bytes prefix = protoDefaultValue!bytes;
}

class InnerOp
{
    @Proto(1) HashOp hash = protoDefaultValue!HashOp;
    @Proto(2) bytes prefix = protoDefaultValue!bytes;
    @Proto(3) bytes suffix = protoDefaultValue!bytes;
}

class ProofSpec
{
    @Proto(1) LeafOp leafSpec = protoDefaultValue!LeafOp;
    @Proto(2) InnerSpec innerSpec = protoDefaultValue!InnerSpec;
    @Proto(3) int maxDepth = protoDefaultValue!int;
    @Proto(4) int minDepth = protoDefaultValue!int;
}

class InnerSpec
{
    @Proto(1, Wire.none, Yes.packed) int[] childOrder = protoDefaultValue!(int[]);
    @Proto(2) int childSize = protoDefaultValue!int;
    @Proto(3) int minPrefixLength = protoDefaultValue!int;
    @Proto(4) int maxPrefixLength = protoDefaultValue!int;
    @Proto(5) bytes emptyChild = protoDefaultValue!bytes;
    @Proto(6) HashOp hash = protoDefaultValue!HashOp;
}

class BatchProof
{
    @Proto(1) BatchEntry[] entries = protoDefaultValue!(BatchEntry[]);
}

class BatchEntry
{
    enum ProofCase
    {
        proofNotSet = 0,
        exist = 1,
        nonexist = 2,
    }
    ProofCase _proofCase = ProofCase.proofNotSet;
    @property ProofCase proofCase() { return _proofCase; }
    void clearProof() { _proofCase = ProofCase.proofNotSet; }
    @Oneof("_proofCase") union
    {
        @Proto(1) ExistenceProof _exist = protoDefaultValue!ExistenceProof; mixin(oneofAccessors!_exist);
        @Proto(2) NonExistenceProof _nonexist; mixin(oneofAccessors!_nonexist);
    }
}

class CompressedBatchProof
{
    @Proto(1) CompressedBatchEntry[] entries = protoDefaultValue!(CompressedBatchEntry[]);
    @Proto(2) InnerOp[] lookupInners = protoDefaultValue!(InnerOp[]);
}

class CompressedBatchEntry
{
    enum ProofCase
    {
        proofNotSet = 0,
        exist = 1,
        nonexist = 2,
    }
    ProofCase _proofCase = ProofCase.proofNotSet;
    @property ProofCase proofCase() { return _proofCase; }
    void clearProof() { _proofCase = ProofCase.proofNotSet; }
    @Oneof("_proofCase") union
    {
        @Proto(1) CompressedExistenceProof _exist = protoDefaultValue!CompressedExistenceProof; mixin(oneofAccessors!_exist);
        @Proto(2) CompressedNonExistenceProof _nonexist; mixin(oneofAccessors!_nonexist);
    }
}

class CompressedExistenceProof
{
    @Proto(1) bytes key = protoDefaultValue!bytes;
    @Proto(2) bytes value = protoDefaultValue!bytes;
    @Proto(3) LeafOp leaf = protoDefaultValue!LeafOp;
    @Proto(4, Wire.none, Yes.packed) int[] path = protoDefaultValue!(int[]);
}

class CompressedNonExistenceProof
{
    @Proto(1) bytes key = protoDefaultValue!bytes;
    @Proto(2) CompressedExistenceProof left = protoDefaultValue!CompressedExistenceProof;
    @Proto(3) CompressedExistenceProof right = protoDefaultValue!CompressedExistenceProof;
}

enum HashOp
{
    NO_HASH = 0,
    SHA256 = 1,
    SHA512 = 2,
    KECCAK = 3,
    RIPEMD160 = 4,
    BITCOIN = 5,
    SHA512_256 = 6,
}

enum LengthOp
{
    NO_PREFIX = 0,
    VAR_PROTO = 1,
    VAR_RLP = 2,
    FIXED32_BIG = 3,
    FIXED32_LITTLE = 4,
    FIXED64_BIG = 5,
    FIXED64_LITTLE = 6,
    REQUIRE_32_BYTES = 7,
    REQUIRE_64_BYTES = 8,
}
